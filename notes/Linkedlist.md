# 链表

数组需要一块连续的内存空间来存储，对内存要求较高，而链表并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来使用。

![image](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

## 单链表

链表通过指针将一组零散的内存空间串联在一起使用。其中，每个内存块称为链表的节点，第一个节点叫头节点，最后一个节点叫尾节点。为了将所有节点串在一起，每个节点除了要存储数据之外，还需要存储下一个节点的地址。记录下个节点地址的指针叫后继指针 next。

![image](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)

### 查找、插入、删除操作

数组插入、删除操作时，为了保持内存连续性，需要做数据搬移，时间复杂度是 O(n)。而在链表插入、删除时，并不需要为了保持内存连续而做数据搬移，只需要考虑相邻节点的指针改变，所以对应的时间复杂度是 O(1)。

![image](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg)

但是，链表要想随机访问第 k 个元素，就没数组那么高效了。因为链表中的数组并非连续存储，无法像数组那样，根据首地址和下标，通过寻址公式直接计算对应的内存地址，而是需要依次遍历，直到找到节点，就需要 O(n) 的时间复杂度。

## 循环链表

循环链表是一种特色的单链表。它跟单链表唯一的区别就在尾节点，单链表指向空地址，而循环链表则指向链表的头节点，像一个环一样首尾相连。

![image](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)

## 双向链表

单链表只有一个方向，节点只有一个后继指针 next。而双向链表，顾名思义，支持两个方向，每个节点除了后继指针 next，还有一个前驱指针 prev。

![image](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)

双向链表需要额外的空间来存储前驱指针，所以比单链表占用更多的内存空间，但支持了双向遍历，带来了操作的灵活性。

### 双向链表为何比单链表高效

#### 插入、删除操作

从链表删除数据无外乎两种情况：
- 删除节点中值等于给定值的节点
- 删除给定指针指向的节点

对于第一种情况，不管单链表还是双链表，为了查找值，都需要从头遍历找到给定值的节点，再通过指针操作删除。尽管单纯的删除操作时间复杂度是 O(1)，但是遍历才是主要耗时点，对应的时间复杂度是 O(n)。所以总的时间复杂度是 O(n)。

对于第二种情况，已经找到要删除的节点，但是删除节点需要知道其前驱节点，单链表不支持直接回去前驱节点，所以需要从头遍历查找。对于双链表，其节点中已保存前驱节点的指针，不需要像单链表一样遍历。所以，针对第二种情况，单链表的时间复杂度是 O(n)，而双链表的时间复杂度则是 O(1)。

> 插入操作同理。这种就是用空间换时间的设计思想，当内存空间充足时，更加追求代码的执行速度，就可以选择空间复杂度较高、但时间复杂度相对较低的算法或数据结构。相反，如果内存紧缺，就要反过来使用时间换空间的设计思想。

## 双向循环链表

把循环链表和双向链表整合在一起就是双向循环链表。

![image](https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg)

## 链表 VS 数组

![image](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)

数组和链表的对比，并不能局限于时间复杂度，在实际软件开发中，不能仅仅利于复杂度分析就决定使用哪个数据结构来存储数据。

数组简单易用，实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。数组的缺点是大小固定，链表本身没有大小限制，这就是它们两者最大的区别

## 如何用链表实现 LRU 缓存淘汰策略

维护一个有序单链表，越靠近尾部的节点是越早之前访问的。当有新数据被访问时，从头遍历链表。
1. 如果此数据之前就已存在链表中，则遍历找到该数据对应节点，将其从原来的位置删除，再插入到链表头部。
2. 如果此数据不存在链表中，则可以分为两种情况：
- 缓存未满，直接插入链表头部。
- 缓存已满，删除链表尾节点，将新数据插入链表头部。

以上实现缓存访问的时间复杂度为 O(n)。因为不管缓存满没满，都需要遍历一遍链表。

> 常见的缓存淘汰策略有三种：先进先出策略 FIFO（First In, First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。

## 如何写出正确的链表代码

### 理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量。

### 警惕指针丢失和内存泄漏

写链表代码的时候，指针指来指去，一下子就不知道知道哪里了。所以在写的时候，一定注意不要弄丢指针。插入节点时，一定要注意操作的顺序，删除节点时，一定要记得释放内存空间。

### 利用哨兵简化实现难度

针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。如果引入哨兵节点，在任何时候，head 指针都会一直指向哨兵节点。把有哨兵节点的链表叫带头链表。相反，没有哨兵节点的链表就叫做不带头链表。

![image](https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg)

### 重点留意边界条件处理

- 如果链表为空，代码能否正常工作
- 如果链表只包含一个节点，代码能否正常工作
- 如果链表包含两个节点，代码能否正常工作
- 如果处理头节点和尾节点时，代码能否正常工作

### 举例画图，辅助思考

举例法和画图法，可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考。比如单链表插入数据这个操作，可以把各种情况都举例，画出差如前插入后的链表变化。

![image](https://static001.geekbang.org/resource/image/4a/f8/4a701dd79b59427be654261805b349f8.jpg)

### 多写多练，没有捷径

常见的链表操作：
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个节点
- 求链表的中间节点