# 数组

数组（Array）是一种线性表结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

> 线性表（Linear list），顾名思义，就是数据排成想一条线一样的结构。每个线性表上的数据最多只有前后两个方向。与线性表对立的概念是非线性表，在非线性表中，数据的关系并不是简单的前后关系。

## 如何实现随机访问

拿一个长度为 10 的 int 类型的数组 int[] a = new int[10] 来举例。如下图，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块收地址为 base_address = 1000。

![image](https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg)

当计算机需要随机访问数组中的某个元素时，会通过如下的寻址公式，计算该元素存储的内存地址：
```
a[i]_address = base_address + i * data_type_size
```
其中 data\_type\_size 表示每个元素的大小。例子中，数组存储的是 int 类型数据，所以 data\_type\_size 为 4。

> 二维数组寻址公式（假设数组大小为 a[m][n] ）：a[i][j]_address = base_address + (i * n + j) * data_type_size

## 低效的“插入”和“删除”

数组为了保持内存数据的连续性，会导致插入、删除两个操作比较低效。假设数组长度为 n，需要将数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，需要将 k～n 这部分的元素都顺序往后挪动一位。如果 k 是在数组末尾，就不需要移动数据，这时的时间复杂度为 O(1)。如果 k 是在数组开头，则所有数据都需要依次完后移动一位，这时的时间复杂度为 O(n)。两种情况分别对应最好最坏情况时间复杂度，因为在每个位置插入元素的概率是一样的，所以平均时间复杂度为 O(n)。

## 警惕数组的访问越界问题

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因此，访问数组的本质就是访问一段连续内存、只要数组通过偏移计算得到的内存地址可用，那么程序不会报错，这种情况下，一般会出现莫名其妙的逻辑错误。

## 容器能否完全替代数组

1. Java 中，容器无法存储基本类型，而Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 数据大小已知，并且对数组操作非常简单，用不到容器提供的大部分方法，也可以直接使用数组。
3. 表示多维数组时，用数组更加直观。

> 对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统的性能。如果做一些非常底层的开发，性能的优化需要做到极致，这个时候数组就优于容器，成为首选。

## 数组为何从 0 开始编号

1. 从数组存储的内存模型看，“下标”最确切的定义应该是“偏移”。对于数组元素内存地址公式，从 1 开始编号相比于从 0 开始编号，每次随机访问数组元素都多了一次减法运算。
2. 更多的是历史原因。